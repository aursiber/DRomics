---
title: Overview of the DRomics package
author: Marie Laure Delignette-Muller, AurÃ©lie Siberchicot, Elise Billoir, Floriane Larras
date: '`r Sys.Date()`'
output:
  html_vignette:
  # pdf_document:
    toc: yes
    number_sections: yes
    toc_depth: 4

vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Overview of the DRomics package} 
  %!\VignetteEncoding{UTF-8}
  \usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# output:
#  html_vignette
require(DRomics)
require(ggplot2)
set.seed(1234)
options(digits = 3)
knitr::opts_chunk$set(echo = TRUE,
                      eval = TRUE, 
                      message=FALSE, 
                      warning=FALSE,
                      cache=FALSE,
                      fig.width = 7, 
                      fig.height = 5)
```


# Introduction {#introduction}

This vignette is intended to help users to start using the DRomics package. It is complementary to the reference manual where you can find more details on
each function of the package. The first part of this vignette ([Main workflow, 
steps 1 to 4](#mainworkflow))
could also help users of the first **Shiny application named DRomics-shiny**. 
The second part (Help for biological interpretation of DRomics outputs)
could also help users of the **second Shiny application named DRomicsInterpreter-shiny**.

Both Shiny applications can be used locally in your R session after installation
of the package and of some required Shiny tools (see below and on the DRomics
web page is you need some more help to install the package: [https://lbbe.univ-lyon1.fr/fr/dromics](https://lbbe.univ-lyon1.fr/fr/dromics))

```{r, eval = FALSE}
# Installation of required Shiny packages
install.packages(c("shiny", "shinyBS", "shinycssloaders", "shinyjs", "shinyWidgets", "sortable"))

# Launch of the first Shiny application DRomics-shiny 
shiny::runApp(system.file("DRomics-shiny", package = "DRomics"))

# Launch of the second Shiny application DRomicsInterpreter-shiny
shiny::runApp(system.file("DRomicsInterpreter-shiny", package = "DRomics"))
```

If you do not want to install the package on your computer, you can also launch the 
two Shiny applications from the Shiny server of our lab, respectively at [https://lbbe-shiny.univ-lyon1.fr/DRomics/inst/DRomics-shiny/](https://lbbe-shiny.univ-lyon1.fr/DRomics/inst/DRomics-shiny/)
and [https://lbbe-shiny.univ-lyon1.fr/DRomics/inst/DRomicsInterpreter-shiny/](https://lbbe-shiny.univ-lyon1.fr/DRomics/inst/DRomicsInterpreter-shiny/).


If you do not want
to use R functions and prefer to use the Shiny applications, 
locally on your computer or from our Shiny server, you can skip the pieces of code and focus on the explanations
and on the outputs that are also given in the Shiny applications. And if one day 
you want go further using the R functions, we recommend you to start
from the whole R code corresponding to your analysis 
that is provided on the last page of each of the two Shiny applications. 

# Main workflow {#mainworkflow}


## Step 1: importation, check and normalization / transformation of data if needed

### General format of imported data

#### Importation of data from a unique text file {#textfile}

Whatever the type of data imported in DRomics (e.g. RNAseq, microarray, metabolomic data),
data can be imported from a .txt file (e.g. "mydata.txt") organized with one row per item (e.g. transcript, probe, metabolite) and one column per sample. In the first row, after a name for the item identifier column (e.g. "id"), we must have the tested doses or concentrations in a numeric format for the corresponding sample
(for example, if there are triplicates for each treatment, the first line could be "item", 0, 0, 0, 0.1, 0.1, 0.1, etc.). The first column must give the identifier of each item (identifier of the probe, transcript, metabolite, ..., or name of the endpoint for anchoring data), 
and the other columns give the responses of the item for each sample.  This file will be imported within DRomics using an internal call to the function read.table() with its default field separator (sep argument). 

Different examples of .txt files formatted for the DRomics workflow
are available in the package, such as the one named 
"RNAseq_sample.txt". You can have a look of how the data are coded in this file using the
following code. To use a local dataset formatted in the same way, such use a datafilename
of type "yourchosenname.txt".


```{r}
# Import the text file just to see what will be automatically imported
datafilename <- system.file("extdata", "RNAseq_sample.txt", package = "DRomics")
# datafilename <- "yourchosenname.txt" # for a local file
# Have a look of what information is coded in this file
d <- read.table(file = datafilename, header = FALSE)
nrow(d)
head(d)
```

#### Importation of data as an R object {#Robject}

**Alternatively an R object of class data.frame 
can be directly given in input**, that corresponds to the output of 
read.table(file, header = FALSE) on a file described in the [previous section](#textfile). 

You can see below an example of an RNAseq data set that is available in DRomics as an R object (named Zhou_kidney_pce) and which is an extended version (more rows) of the previous dataset coded in "RNAseq_sample.txt".

```{r}
# Load and look at the dataset directly coded as an R object
data(Zhou_kidney_pce)
nrow(Zhou_kidney_pce)
head(Zhou_kidney_pce)
```

#### Formating of data within R using the formatdata4DRomics() function {#format4DRomics}

**If your data are already imported in R in a different format as the one described 
in the [previous
section](#Robject), you can use the
formatdata4DRomics() function to build an R object directly useable by the DRomics
workflow**. 
formatdata4DRomics() needs two arguments in input:

+ the matrix of the data with one row for each item and one column for each sample,
+ and the numeric vector coding for the dose for each sample. 

The names of the samples
can be added in a third optional argument (see ?formatdata4DRomics for details). 
Below is an example
using a RNAseq dataset of the package coded as an R object named zebraf. 

```{r}
# Load and look at the data as initially coded
data(zebraf)
str(zebraf)

# Formatting of data for use in DRomics
# 
data4DRomics <- formatdata4DRomics(signalmatrix = zebraf$counts, 
                           dose = zebraf$dose)
# Look at the dataset coded as an R object
nrow(data4DRomics)
head(data4DRomics)
```

**We recommend you to carefully look at the following sections to check that you use the good scale for you data, which depends on the type of measured signal 
(counts of reads, fluorescence signal, ...).**

### Types of data that may be imported in DRomics {#datatypes}

#### General description of the different types of data handled by DRomics

DRomics offers the possibility to work on different types of omics
data (see following subsections for their description) 
but also on continuous anchoring data.
**When working on omics data, all the lines of the data frame**
(except the first one coding for the doses or concentrations)
**correspond to the same type of data** 
(e.g. raw counts for RNAseq data).
**When working on anchoring data, the different lines** 
(except the first one coding for the doses or concentrations)
**correspond to different endpoints that may correspond to different
types of data** (e.g. biomass, length,..), but all are assumed continuous data
compatible with a normal error distribution (e.g. after logarithmic transformation) for the 
selection and modelling steps.

Three types of omics data may be imported in DRomics using the following functions:

+ **RNAseqdata()** should be used to import **RNAseq as counts of reads**,
+ **microarraydata()** should be used to import **single-channel microarray data in log2 scale**,
+ **continuousomicdata()** should be used to import **other continuous omics data** such as metabolomics, proteomics,..., **in a scale that enables the use of a normal error model** 
in Steps [2](#step2) and [3](#step3). metabolomicdata() is the former name, but still available, of this function.

In Steps [1](#step1) and [2](#step2) **count data** are internally analysed using 
functions of 
the Bioconductor package [DESeq2](https://bioconductor.org/packages/release/bioc/html/DESeq2.html) while continuous data 
(**microarray data and other continuous omics data**) are internally analysed using functions
of the Bioconductor package [limma](https://www.bioconductor.org/packages/release/bioc/html/limma.html). 


#### An example with RNAseq data {#RNAseqexample}

```{r}
RNAseqfilename <- system.file("extdata", "RNAseq_sample.txt", package = "DRomics")
# RNAseqfilename <- "yourchosenname.txt" # for a local file
```

For RNAseq data, imperatively imported in raw counts, you have to choose the transformation
method used to stabilize the variance 
("rlog" or "vst"). In the example below "vst" was used 
to make this vignette quick to compile, 
but **"rlog" is recommended and chosen by default even if more computer intensive than "vst"**
(except when the number of samples is very large (> 30) as encountered for in situ data for example, see ?RNAseqdata and the [section dedicated to in situ data](#insitudata) for details on this point). 
Whatever the chosen method, 
data are automatically normalized with respect to library size and transformed in log2 scale.


```{r}
(o.RNAseq <- RNAseqdata(RNAseqfilename, transfo.method = "vst"))
plot(o.RNAseq, cex.main = 0.8, col = "green")
```

#### An example with microarray data {#microarrayexample}

For single-channel microarray data, imperatively imported in log
scale (classical and recommended log2 scale), you can choose between array 
normalization methods ("cyclicloess", "quantile", "scale" or "none"). 
In the example below "quantile" was used 
to make this vignette quick to compile, 
but **"cyclicloess" is strongly recommended and chosen by default even if more computer intensive than the others** 
(see ?microarraydata for details).


```{r}
microarrayfilename <- system.file("extdata", "transcripto_sample.txt", package = "DRomics")
# microarrayfilename <- "yourchosenname.txt" # for a local file
```


```{r}
(o.microarray <- microarraydata(microarrayfilename, norm.method = "quantile"))
plot(o.microarray, cex.main = 0.8, col = "green")

```

#### An example with metabolomic data {#metabolomicexample}

```{r}
metabolofilename <- system.file("extdata", "metabolo_sample.txt", package = "DRomics")
# metabolofilename <- "yourchosenname.txt" # for a local file
```

No normalization nor transformation is provided in the function continuousomicdata(). The pre-treatment of metabolomic data must be done before importation of data, and data must be imported in log scale, so that they can be directly modelled using a normal error model. This strong hypothesis is required both for selection of items and for dose-reponse modelling. In the context of a multi-omics approach we recommend the use of a log2 transformation, instead of the classical log10 for such data, so as to facilitate the comparison of
results obtained with transcriptomics data generally handled in a log2 scale.

As an example, a basic procedure for the pre-treatment of metabolomic data could follow the three steps described thereafter: i) removing of metabolites for which the proportion of missing data (non detected) across all the samples is too high (more than 20 to 50 percents according to your tolerance level); ii) retrieving of missing values data using half minimum method (i.e. half of the minimum value found for a metabolite across all samples); iii) log-transformation of values. If a scaling to the total intensity (normalization by sum of signals in each sample) or another normalization is necessary and pertinent, we recommend to do it before those three previously described steps.

```{r}
(o.metabolo <- continuousomicdata(metabolofilename))
plot(o.metabolo, col = "green")
```

The metabolomicdata() function was renamed continuousomicdata() in the recent versions
of the package (while keeping the first name available) 
to offer its use to other continuous omic data such as proteomics data or RT-qPCR data. 
As for metabolomic data, the pre-treatment of other continuous omic data must be done before importation, and data must be imported in a scale that enables the use of a 
normal error model. This strong hypothesis is required both for selection of items and for dose-response modelling.

#### An example with continuous anchoring apical data {#apicalexample}

```{r}
anchoringfilename <- system.file("extdata", "apical_anchoring.txt", package = "DRomics")
# anchoringfilename <- "yourchosenname.txt" # for a local file
```

No transformation is provided in the function continuousanchoringdata(). If needed the pre-treatment of data must be done before importation of data, so that they can be directly modelled using a normal error model. This strong hypothesis is required both for selection of responsive endpoints and for dose-reponse modelling. 

For such data the plot() function provides a dose-response plot for each endpoint.
In this example the argument backgrounddose is used to specify that doses below  or equal to 0.1
are considered as 0 in the DRomics workflow.
Specifying this argument is necessary when there is no dose at 0 in the data (see [section
on in situ data](#insitudata) for details on this point). 

```{r}
(o.anchoring <- continuousanchoringdata(anchoringfilename, backgrounddose = 0.1))
plot(o.anchoring)
```


### Handling of data with specific designs {#specificdesigns}

The DRomics workflow was first developed for data collected through a typical
dose-response experiment, with a reasonable number of tested doses (or concentrations - at least 4 in addition to the control and ideally 6 to 8)
and a small number of replicates per dose. Recently we made some modifications in the package to make possible the use of designs with only 3 doses in addition to the control even if this type of design is not recommended for dose-response modeling.
**We also extended our workflow to handle in situ (or observational) datasets**, 
for which there are **no replication, as the dose (or concentration) is not controlled**
(see the next subsection for an example and more information on the handling of such data).
In the following, you will also find an example of **experimental data collected using a design with a batch effect** with an explanation of a simple way to use functions 
from the Bioconductor package [sva](https://bioconductor.org/packages/release/bioc/html/sva.html) to correct for this batch effect and to use our PCAplot()
function to visualize this batch effect and the impact of the batch effect correction on data.

#### An example with in situ (observational) RNAseq data {#insitudata}

One of the problem that may occur in particular with in situ data, is the absence of real
control samples, corresponding to a strictly null exposure dose or concentration.
To prevent an hazardous calculation of the BMD by extrapolation in such a case, 
one should use the argument backgrounddose to define the maximal measured dose 
that can be considered as a negligible dose. 
All doses below  or equal to the value given in backgrounddose will be fixed at 0, 
so as to be considered at the background level of exposition. 

For in situ data (and more generally for data with a very large number of samples),
the use of the rlog transformation in RNAseqdata() is not recommended, both for speed
reason and because you are more likely to encounter a problem with the rlog transformation in 
case of outliers in such a case (see  [https://support.bioconductor.org/p/105334/](https://support.bioconductor.org/p/105334/)
for an explanation of the author of [DESeq2](https://bioconductor.org/packages/release/bioc/html/DESeq2.html) and just force the transfo.method to 
"rlog" in the following example to see an example of problems with outliers).

```{r}
datafilename <- system.file("extdata", "insitu_RNAseq_sample.txt", package="DRomics")
# Importation of data specifying that observed doses below the background dose
# fixed here to 2e-2 will be considered as null dose to have a control 
(o.insitu <- RNAseqdata(datafilename, backgrounddose = 2e-2, transfo.method = "vst"))
plot(o.insitu)
```

#### An example with RNAseq data from an experiment with a batch effect {#batcheffect}

When omics data are collected through a design with a known batch effect, 
the DRomics function PCAplot() can be used as in the example below to visualize
the impact of this batch effect on the data, and functions from specific
packages can be used to correct for the batch effect as in the example below.
We recommend the use of functions ComBat() and ComBat_seq() from the Bioconductor
**sva** package for this purpose, respectively for microarray 
(or other continuous omic data) and RNAseq data. Below is an example using 
ComBat-seq() on RNAseq data with batch effect.

```{r}
# Load of data
data(zebraf)
str(zebraf)

# Formating of data using the formatdata4DRomics() function
data4DRomics <- formatdata4DRomics(signalmatrix = zebraf$counts, 
                           dose = zebraf$dose)

# Normalization and transformation of data 
(o <- RNAseqdata(data4DRomics, transfo.method = "vst"))

# PCA plot to visualize the batch effect
PCAdataplot(o, batch = zebraf$batch)

# Batch effect correction using ComBat_seq{sva}
require(sva)
BECcounts <- ComBat_seq(as.matrix(o$raw.counts), 
                        batch = as.factor(zebraf$batch), 
                        group = as.factor(o$dose)) 

# Formating of data after batch effect correction
BECdata4DRomics <- formatdata4DRomics(signalmatrix = BECcounts, 
                                   dose = o$dose)
(o.BEC <- RNAseqdata(BECdata4DRomics, transfo.method = "vst"))

# PCA plot after batch effect correction
PCAdataplot(o.BEC, batch = zebraf$batch)
```


## Step 2: selection of significantly responding items {#step2}

For the second step of the workflow, the function itemselect() must be used with the output of the function used in [step 1](#step1) as first argument (output of RNAseqdata(), microarraydata(), continuousomicdata() or continuousanchoringdata()). Below is an example with microarray data.

The false discovery rate (FDR) corresponds to the expected proportion of items that will be falsely
detected as responsive. With a very large data set it is important to define a selection step based
on an FDR not only to reduce the number of items to be further processed, but also to remove
too noisy dose-response signals that may impair the quality of the results.
We recommend to set a value between 0.001 and 0.1 depending of the initial number of items. 
When this number is very high (more than several tens of thousands),
we recommend a FDR less than 0.05 (0.001 to 0.01) to increase the robustness of the results ([Larras et al. 2018](https://hal.archives-ouvertes.fr/hal-02309919/document)).

Concerning the method used for selection, we recommend the default choice ("quadratic") for a typical omics dose-response design (many doses/concentrations with few replicates
per condition). It enables the selection of both monotonic and 
biphasic dose-response relationships. If you want to focus on monotonic dose-response relationships, the "linear" method could be chosen. For a design with a small number of doses/concentrations and many replicates 
(not optimal for dose-response modelling), the "ANOVA" method could be preferable.
For in situ data (observational data without replicates due to uncontrolled dose), only trend tests
will be proposed as the use of an ANOVA test in absence of replicates for some conditions is not reasonable.

See ?itemselect and [Larras et al. 2018](https://hal.archives-ouvertes.fr/hal-02309919/document) for details.

```{r}
(s_quad <- itemselect(o.microarray, select.method = "quadratic", FDR = 0.01))
```

## Step 3: fit of dose-response models, choice of the best fit for each curve {#step3}

### Fit

For Step 3 the function drcfit() must be simply used with the output of itemselect() as first argument. Description of the fitted models and of the procedure to select the best fit are described in [Larras et al. 2018](https://hal.archives-ouvertes.fr/hal-02309919/document) and in ?drcfit. **The former use of the AIC** (Akaike criterion-
default information criterion used for the selection of the best fit model in DRomics versions
< 2.2-0) was **replaced by the use of the AICc** (second-order Akaike criterion)
in order to prevent the overfitting that may occur with dose-response designs
with a small number of data points, as recommended
and now classically done in regression 
(Hurvich and Tsai, 1989; Burnham and Anderson DR, 2004).

As the call to this function may take time, by default a progressbar is provided.
Some arguments of this function can be used to specify parallel computing to
accelerate the computation (see ?drcfit for details). 

```{r}
(f <- drcfit(s_quad, progressbar = FALSE))
```

In the following you can see the first ten lines of the output data frame 
on our example (see ?drcfit for a complete description
of the columns of the output data frame.) This output data frame provides information such as best-fit model, parameter value, coordinates of particular points, and the trend of the curve (among increasing, decreasing, U-shaped, bell-shaped) 

```{r}
head(f$fitres, 10)
```

### Plot of fitted curves

By default the plot() function used on the output of the drcfit() function 
provides the first 20 fitted curves (or the ones you specify using the argument items) with observed points. Fitted curves are represented in red, replicates are
represented in open circles and means of replicates at each dose/concentration
are represented by solid circles. All the fitted curves may be
saved in a pdf file using the plotfit2pdf() function (see ?drcfit).

```{r}
plot(f) 
```

The fitted curves may be represented using a log
scale for the dose/concentration using argument dose_log_transfo (see ?drcfit for details and examples).

Another specific plot function named targetplot() can be used to
plot targeted items, whether they were or not selected in step 2 and fitted in step 3. See an example below and details in ?targetplot

```{r}
targetitems <- c("88.1", "1", "3", "15")
targetplot(targetitems, f = f)
```

### Plot of residuals

To check the assumption of the normal error model, two types of residual plots can
be used ("dose_residuals" or "fitted_residuals"). The residual plots for
all items may also be
saved in a pdf file using the plotfit2pdf() function (see ?drcfit).

```{r, fig.width = 7, fig.height = 5}
plot(f, plot.type = "dose_residuals")
```


## Step 4: calculation of x-fold and z-SD benchmark doses {#step4}

### Calculation of BMD

The two types of benchmark doses (BMD-zSD and BMD-xfold) proposed by 
the EFSA (2017) are systematically calculated
for each fitted dose-response curve using the function bmdcalc() with the output
of the drcfit() function as a first argument (see [Larras et al. 2018](https://hal.archives-ouvertes.fr/hal-02309919/document) 
or ?drcfit for details).

The argument z, by default at 1, is used to define the BMD-zSD as the dose at which the response is reaching y0 +/- z * SD, with y0 the level at the control given by the dose-response fitted model and SD the residual standard deviation of the dose-response fitted model. 

The argument x, 
by default at 10 (for 10%), is used to define the BMD-xfold as the dose at which the response is reaching y0 +/- (x/100) * y0.

```{r}
(r <- bmdcalc(f, z = 1, x = 10))
```

In the following you can see the first ten lines of the output data frame 
of the function bmdcalc()
on our example (see ?bmdcalc for a complete description of the
columns of the output data frame).

```{r}
head(r$res, 10)
```

### Various plots of the BMD distribution

The default plot of the output of the bmdcalc() function provides the distribution of benchmark doses as an ECDF
(Empirical Cumulative Density Function) plot for the chosen BMD ("zSD"" or "xfold"). See an example below.

```{r}
plot(r, BMDtype = "zSD", plottype = "ecdf") 
```

Different alternative plots are proposed (see ?bmdcalc for details)
that can be obtained using the argument plottype to choose the type of plot 
("ecdf", "hist" or "density") and the argument by to split the
plot by "trend", "model" or "typology". Below is an example
of a density plot of BMD-zSD split by trend of dose-response
curves.


```{r}
plot(r, BMDtype = "zSD", plottype = "density", by = "trend") 
```

### Plot of BMD distribution with a color gradient for signal intensity

On a BMD ECDF plot one can add a color gradient for each item coding for 
the intensity of the signal (after shift of the control signal at 0) as a function of the dose (see ?bmdplotwithgradient for details
and an example below).

```{r}
bmdplotwithgradient(r$res, BMDtype = "zSD",
                    facetby = "trend", 
                    shapeby = "model") + labs(shape = "model")
```

You can use the argument line.size to manually
adjust the width of lines in that plot if the default value does not give
a visual result that suits you. It is also recommended to scale the signal
as below using the argument scaling if you want to focus on the 
shape of the dose-reponse curves and not on the amplitude of the signal change.

```{r}
bmdplotwithgradient(r$res, BMDtype = "zSD",
                    facetby = "trend", 
                    shapeby = "model",
                    line.size = 1.2,
                    scaling = TRUE) + labs(shape = "model")
```


### Plot of fitted curves with BMD values

It is possible to add the output of bmdcalc()
in the argument BMDoutput of the plot() function of drcfit() to add BMD values
(when defined) as a 
vertical line on each fitted curve. Horizontal dotted lines corresponding to the two BMR potential
values will be also added.
All the fitted curves may also be
saved in the same way in a pdf file using the plotfit2pdf() function (see ?drcfit).

```{r}
plot(f, BMDoutput = r) 
```


## Step 5: calculation of confidence intervals on the BMDs by bootstrap 

Confidence intervals on BMD values can be calculated by bootstrap.
As the call to this function may take much time, by default a progressbar is provided and some arguments can be used to specify parallel computing to
accelerate the computation (see ?bmdboot for details).

In the example below a small number of iterations was used just 
to make this vignette quick to compile, but **the default value of the argument niter (1000) should be considered as a minimal value to obtain stable results**.

### Bootstrap calculation {#bootstrap}
```{r}
(b <- bmdboot(r, niter = 50, progressbar = FALSE))
```

This function gives an output corresponding to the output of
the bmdcalc() function completed with bounds of BMD confidence
intervals (by default 95% confidence intervals).

```{r}
head(b$res, 10)
```


### Add of confidence intervals on BMD ECDF plots 

The plot() function applied on the output the bmdboot() function
gives an ECDF plot of the chosen BMD with the confidence interval
of each BMD (see an example below). By default BMDs with an infinite 
confidence interval bound are not plotted.


```{r}
plot(b, BMDtype = "zSD", by = "trend") 
```

### Plot of fitted curves with BMD values and confidence intervals

It is possible to add the output of bmdboot()
in the argument BMDoutput of the plot() function of drcfit() to add BMD values 
(when defined) as a 
vertical line on each fitted curve and bounds of the confidence intervals 
(when successfully calculated) as two dashed lines. 
Horizontal dotted lines corresponding to the two BMR potential
values will be also added.
All the fitted curves may also be
saved in the same way in a pdf file using the plotfit2pdf() function (see ?drcfit).

```{r}
plot(f, BMDoutput = b) 
```


# Help for biological interpretation of DRomics outputs {#interpreter}

This section illustrates functions of DRomics that are meant to help the biological interpretation of outputs. The idea is to augment the output data frame with new column(s) bringing biological information such as provided by biological annotation of the items (e.g. kegg pathway classes or GO terms) then to use this information to organize the visualisation of the DRomics output.

The Shiny application 
DRomicsInterpreter-shiny can be used to implement all the steps described in this vignette without coding them in R. But in any case, the biological annotation of items selected in the first DRomics workflow must be done outside DRomics using a database such as the Gene Ontology (GO) of the kegg databases.

In this section we will first present a simple example from a metabolomic dataset and then a example with two molecular levels using metabolomic and transcriptomic data from the same experiment, to illustrate how to compare the responses at different experimental levels (in this example different molecular levels). The different experimental levels could also be different time points, 
different experimental settings, different species, ...

## Interpretation of DRomics results in a simple case with only one data set obtained in one experimental condition

### Augmentation of the data frame of DRomics results with biological annotation {#augmentation}

This augmentation is not done using DRomics functions, but with relevant R functions such as merge(). 
Nevertheless it is possible to perform it without R coding within the Shiny application
DRomicsInterpreter-shiny. Report to the [introduction section](#introduction) to see how to launch the Shiny application.

An example of how to proceed:

1. **Import the data frame with DRomics results to be used: the output $res of bmdcalc() or bmdboot() functions from step 4 or 5 of the main DRomics workflow.**

(This step will not be necessary if previous steps are done directly in R using the DRomics package as described previously in this vignette. We did it to take a real example that took a long time to run but from which results are stored in the package.)

```{r}
# code to import the file for this example in our package
resfilename <- system.file("extdata", "triclosanSVmetabres.txt", package = "DRomics")
res <- read.table(resfilename, header = TRUE, stringsAsFactors = TRUE)

# to see the structure of this file
str(res)
```

2. **Import the data frame with biological annotation (or any other descriptor/category you want to use, here KEGG pathway classes) of each item present in the 'res' file.**

Examples are embedded in the DRomics package, but be cautious, generally this file must be produced by the user. Each item may have more than one annotation (*i.e.* more than one line). 

```{r}
# code to import the file for this example in our package
annotfilename <- system.file("extdata", "triclosanSVmetabannot.txt", package = "DRomics")
# annotfilename <- "yourchosenname.txt" # for a local file
annot <- read.table(annotfilename, header = TRUE, stringsAsFactors = TRUE)

# to see the structure of this file
str(annot)
```

3. **Merging of both previous data frames in order to obtain a so-called 'extendedres' data frame gathering, for each item, metrics derived from the DRomics workflow and biological annotation.**

Arguments by.x and by.y of the merge() function 
indicate the column name in res and annot data frames, respectively, that must be used for the merging.  

```{r}
extendedres <- merge(x = res, y = annot, by.x = "id", by.y = "metab.code")
head(extendedres)
```

### Various plots of results by biological group

#### BMD ECDF plots split by group defined from biological annotation {#bmdplot}

Using the function bmdplot() and its argument facetby, the BMD ECDF plot can be split
by group (here by KEGG pathway class). 
Confidence intervals can be added on this plot and color coding for trend in this example
(See ?bmdplot for more options).

```{r}
bmdplot(extendedres, BMDtype = "zSD", add.CI = TRUE, 
                    facetby = "path_class", 
                    colorby = "trend") + labs(col = "trend")
```

The function ecdfplotwithCI() can also used as an alternative as below to provide the same plot
differing just by the coloring of intervals only. (See ?ecdfplotwithCI for more options.)

```{r, eval = FALSE}
ecdfplotwithCI(variable = extendedres$BMD.zSD, 
               CI.lower = extendedres$BMD.zSD.lower, 
               CI.upper = extendedres$BMD.zSD.upper, 
               by = extendedres$path_class,
               CI.col = extendedres$trend) + labs(col = "trend")
```

Using the function bmdplotwithgradient() and its argument facetby, the BMD plot with color gradient can be split here by KEGG pathway class. (See ?bmdplotwithgradient for more options).

```{r}
bmdplotwithgradient(extendedres, BMDtype = "zSD",
                    scaling = TRUE, 
                    facetby = "path_class", 
                    shapeby = "trend") + labs(shape = "trend")
```

One can focus on a group of interest, for instance the group "Lipid metabolism", and add the labels of items
using argument add.label as below to display item identifiers instead of points. 
In that case in can be useful 
to control the limits of the color gradient and the limits
on the x-axis in order to use the same x-scale and signal-scale,
as in the following example (see ?bmdplotwithgradient for details).

```{r}
extendedres_lipid <- extendedres[extendedres$path_class == "Lipid metabolism",] 

bmdplotwithgradient(extendedres_lipid, BMDtype = "zSD",
                    scaling = TRUE,
                    facetby = "path_class", 
                    add.label = TRUE,
                    xmin = 0, xmax = 6,
                    label.size = 3,
                    line.size = 2) 

```


#### Sensitivity plot of biological groups {#sensitivityplot}

It is also possible to show a summary of BMD values in each pathway/category as a chosen summary (argument BMDsummary which can be "first.quartile", "median" or "median.and.IQR" for
medians with the interquartile range as an interval) using the function sensitivityplot(). 
Moreover, this function will provide information on the number of items involved in each pathway/category. (See ?sensitivityplot for more options).

As an example, below is an ECDF plot of 25th quantiles of BMD-zSD calculated here by pathway class. 

```{r}
sensitivityplot(extendedres, BMDtype = "zSD",
                    group = "path_class",
                 BMDsummary = "first.quartile") 
```

#### Trend plot per biological group {#trendplot}

It is possible to represent the repartition of trends in each biological group
using function trendplot() (see ?trendplot for details).

```{r}
trendplot(extendedres, group = "path_class") 
```

#### Plot of dose-response curves per biological group {#curvesplot}

The function curvesplot() can show the dose-response curves obtained for different groups
(or one chosen group). As for the use of bmdplotwithgradient(), the scaling of those curves can be used
as soon as you want to focus on the shape of them, and not on the amplitude of the signal change. To use this function you have to define the dose range on which you want the computation of the dose-response fitted curves, and we strongly recommend you to choose a range corresponding to the range of tested/observed doses
in your dataset. Below is a code to plot the dose-response curves split by biological group (argument facetby) and colored by trend (argument colorby). (See ?curvesplot for more options).

```{r}
# Plot of all the scaled dose-reponse curves split by path class
curvesplot(extendedres, facetby = "path_class", scaling = TRUE, npoints = 100, line.size = 1,
           colorby = "trend", xmin = 0, xmax = 6.5) + labs(col = "trend")

# Plot of the unscaled dose-reponses for one chosen group, split by metabolite
LMres <- extendedres[extendedres$path_class == "Lipid metabolism", ]
curvesplot(LMres, facetby = "id", npoints = 100, line.size = 1,
           colorby = "trend",
           xmin = 0, xmax = 6.5) + labs(col = "trend")
```


## Interpretation of DRomics results taking into account an experimental level for example in a multi-omics approach  {#multilevels}

This section illustrates functions of DRomics that are meant to help the interpretation of outputs by taking into account **different experimental levels (different molecular levels, different time points, different experimental settings, ...)**. The idea is to augment the output data frame with new column(s) bringing information on this experimental level, then to use this information to organize the visualisation of the DRomics output and so make possible the **comparison of the responses between each experimental levels**. 

Below is used an example corresponding to a multi-omics approach, the experimental level corresponding to the molecular level, with a transcriptomic (microarray) and a metabolomic data set issued from the same experiment. 
This example uses metabolomics and transcriptomics data for *Scenedesmus* and triclosan published by [Larras et al. in 2020](https://doi.org/10.1016/j.jhazmat.2020.122727).

### Augmentation of the data frames of DRomics results with biological annotation

Following the same steps as [described before for metabolomics](#augmentation), below is an example of R code to import the DRomics results for microarray data, and to merge them with information on biological annotation.

```{r}
# 1. Import the data frame with DRomics results to be used
contigresfilename <- system.file("extdata", "triclosanSVcontigres.txt", package = "DRomics")
contigres <- read.table(contigresfilename, header = TRUE, stringsAsFactors = TRUE)
str(contigres)

# 2. Import the data frame with biological annotation (or any other descriptor/category 
# you want to use, here KEGG pathway classes) 
contigannotfilename <- system.file("extdata", "triclosanSVcontigannot.txt", package = "DRomics")
# contigannotfilename <- "yourchosenname.txt" # for a local file
contigannot <- read.table(contigannotfilename, header = TRUE, stringsAsFactors = TRUE)
str(contigannot)

# 3. Merging of both previous data frames   
contigextendedres <- merge(x = contigres, y = contigannot, by.x = "id", by.y = "contig")
# to see the structure of this data frame
str(contigextendedres)
```

The [previouly created](#augmentation) metabolomics data frame (extended results with biological annotation) is renamed for the sake of homogeneity.

```{r}
metabextendedres <- extendedres
```

### Binding of the data frames corresponding the results at each experimental level {#binding}
The next step is the binding of data frames at the different levels (here
transcriptomics and metabolomics data frames) by adding a variable (here named level) coding for the level (here a factor with two levels, metabolites and contigs).

```{r}
extendedres <- rbind(metabextendedres, contigextendedres)
extendedres$explevel <- factor(c(rep("metabolites", nrow(metabextendedres)),
                              rep("contigs", nrow(contigextendedres))))
str(extendedres)
```

### Comparison of results obtained at the different experimental levels using basic R functions {#comparisonR}

Below are examples of illustrations that can be used to compare the results obtained at several levels of biological organization using basic R functions
for example to compute and plot frequencies of pathways by molecular levels as below.

```{r}
(t.pathways <- table(extendedres$path_class, extendedres$explevel)) 
original.par <- par()
par(las = 2, mar = c(4,13,1,1))
barplot(t(t.pathways), beside = TRUE, horiz = TRUE, 
        cex.names = 0.7, legend.text = TRUE, 
        main = "Frequencies of pathways")
par(original.par)
```

To do the same plot in proportions, just apply the function
prop.table() to the table of frequencies t.pathways.

<!-- ### Proportions of pathways per molecular level -->

<!-- Here basic R functions are used to compute and plot proportions of pathways by molecular levels. -->

<!-- ```{r} -->
<!-- (t.prop.pathways <- prop.table(t.pathways, margin = 2))  -->
<!-- original.par <- par() -->
<!-- par(las = 2, mar = c(4,13,1,1)) -->
<!-- barplot(t(t.prop.pathways), beside = TRUE, horiz = TRUE,  -->
<!--         cex.names = 0.7, legend.text = TRUE,  -->
<!--         main = "Proportion of pathways") -->
<!-- par(original.par) -->
<!-- ``` -->

Here the ggplot2 grammar is used to plot the ECDF of BMD_zSD using different colors for the different molecular levels.

```{r}
if (require(ggplot2))
{
   ggplot(extendedres, aes(x = BMD.zSD, color = explevel)) +
      stat_ecdf(geom = "step") + ylab("ECDF")
   
}
```


<!-- ```{r} -->
<!-- if (require(ggplot2)) -->
<!-- { -->
<!--    ggplot(extendedres, aes(x = BMD.zSD)) + facet_wrap(~ level) + -->
<!--       stat_ecdf(geom = "step") + ylab("ECDF") -->

<!-- } -->
<!-- ``` -->

<!-- ### Comparison of results obtained at different molecular levels using DRomics functions -->

<!-- With DRomics functions bmdplot(), bmdplotwithgradient(), sensitivityplot(), trendplot() and curvesplot(),  -->
<!-- it is also possible to easily integrate different molecular levels (or another grouping level). -->


### Comparison of results obtained at the different experimental levels using DRomics functions {#comparisonDRomics}

#### ECDF plot of BMD values per group and experimental level using DRomics functions

Using the function bmdplot() the ECDF plot of the BMD-zSD values can be colored or split by experimental level and/or split
by group (here by KEGG pathway class) as below. 
(See ?bmdplot for more options, for example to add confidence intervals, ...,
as in [the previous section presenting bmdplot()](#bmdplot)).

```{r}
# BMD ECDF plot split by molecular level
bmdplot(extendedres, BMDtype = "zSD", 
                    facetby = "explevel") 

# BMD ECDF plot colored by molecular level and split by path class
bmdplot(extendedres, BMDtype = "zSD", 
                    facetby = "path_class", 
                    colorby = "explevel") + labs(col = "molecular level")
```

<!-- Below is a focus on few pathways with split on pathway and molecular level. -->

<!-- ```{r} -->
<!-- chosen_path_class <- c("Membrane transport", "Lipid metabolism", "Energy metabolism") -->
<!-- selectedres <- extendedres[extendedres$path_class %in% chosen_path_class, ] -->
<!-- bmdplot(selectedres, BMDtype = "zSD", add.CI = TRUE,  -->
<!--                     facetby = "path_class",  -->
<!--                     facetby2 = "explevel") + labs(col = "trend") -->
<!-- ``` -->

#### Plot of the trend repartition per group and experimental level

Using the function trendplot() and its arguments facetby it is possible 
to show the repartition of trends of responses in each biological group 
for all experimental levels.

```{r}
# Preliminary optional alphabetic ordering of path_class groups
extendedres$path_class <- factor(extendedres$path_class, 
                levels = sort(levels(extendedres$path_class), decreasing = TRUE))

# Trend plot
trendplot(extendedres, group = "path_class", facetby = "explevel") 
```

#### Sensitivity plot per group and experimental level

Using the function sensitivityplot() and its arguments group and colorby, 
it is possible to show a summary of BMD values with size of points coding for the number
of items in each group as in the example, where the 25th quartiles of BMD values are represented per KEGG pathway class for each molecular level. (See ?sensitivityplot for more options).


```{r}
sensitivityplot(extendedres, BMDtype = "zSD",
                group = "path_class", colorby = "explevel",
                BMDsummary = "first.quartile") 
```


#### Selection of groups on which to focus using the selectgroups() function

When the number of biological groups obtained after annotation of items is too high, it may be useful
to select groups on which to focus, to enhance the visibility of plots.
This can be done for example using results of enrichment procedures in the case 
where enrichment is possible (e.g. for sequenced organisms). One could also
use selection criteria based on the number of items in each biological
group (argument nitems, to select the most represented groups) and/or on the BMD summary value 
(argument BMDmax, to select the most sensitive groups). The selectgroups() function can be used for this purpose as in the example below (see ?selectgroups for details).
When using this function you can choose to keep the results of all
the experimental levels (for comparison purpose)
as soon as the criteria are met for the group
for at least one experimental level (as in the example below fixing the argument
keepallexplev at TRUE).

```{r}
selectedres <- selectgroups(extendedres, 
                         group = "path_class",
                         explev = "explevel",
                         BMDmax = 0.75,
                         BMDtype = "zSD", 
                         BMDsummary = "first.quartile",
                         nitems = 3,
                         keepallexplev = TRUE)

# BMDplot on this selection
bmdplot(selectedres, BMDtype = "zSD", add.CI = TRUE,
                    facetby = "path_class", facetby2 = "explevel",
                    colorby = "trend") + labs(col = "trend")
```


#### BMD ECDF plot with color gradient split by group and experimental level

Using the function bmdplotwithgradient() and its arguments facetby and facetby2, 
the BMD plot with color gradient can be split here by KEGG pathway class
and molecular level, here on a selection of pathway classes present at both molecular levels.(See ?bmdplotwithgradient for more options).
Especially as metabolomic data and transcriptomic data were not imported
in DRomics in the same scale (in log2 for transcriptomics and log10 for metabolomics), 
the use of the scaling option of each dose-reponse curve is interesting in such case. 
This option focuses on the shape of responses, skipping the amplitude of changes to the control. Below is an example of BMD plot with color gradient on
a manual selection of groups.

```{r}
# Manual selection of groups on which to focus
chosen_path_class <- c("Nucleotide metabolism", 
                       "Membrane transport", 
                       "Lipid metabolism", 
                       "Energy metabolism")
selectedres2 <- extendedres[extendedres$path_class %in% chosen_path_class, ]
bmdplotwithgradient(selectedres2, BMDtype = "zSD", scaling = TRUE,
               facetby = "path_class", facetby2 = "explevel")
```


#### Plot of the dose-response curves for a selection of groups

Using the function curvesplot(), specific dose-response curves can be shown. In this example, first only results related to the "lipid metabolism" pathway class are kept. Then, the plot is split by molecular level (argument facetby) and colored by trend (argument colorby). (See ?curvesplot for more options). The scaling of the curves 
used in the second plot of the following example can be interesting to focus on the 
shapes of those curves, skipping the amplitude of the changes from the control.
This helps to evaluate the homogeneity of the shapes of the responses within each group.


```{r}
# Plot of the unscaled dose-response curves for the "lipid metabolism" path class
LMres <- extendedres[extendedres$path_class == "Lipid metabolism", ]
curvesplot(LMres, facetby = "explevel", free.y.scales = TRUE, npoints = 100, line.size = 1,
           colorby = "trend",
           xmin = 0, xmax = 6.5) + labs(col = "DR_trend")

# Plot of the scaled dose-response curves for previously chosen path classes
curvesplot(selectedres2, scaling = TRUE,
           facetby = "path_class", facetby2 = "explevel",
           npoints = 100, line.size = 1,
           colorby = "trend",
           xmin = 0, xmax = 6.5) + labs(col = "DR_trend")
```


# References 

+ Burnham, KP, Anderson DR (2004). Multimodel inference: understanding AIC and BIC in model selection. Sociological methods & research, 33(2), 261-304.

+ EFSA Scientific Committee, Hardy A, Benford D, Halldorsson T, Jeger MJ, Knutsen KH, ...
& Schlatter JR  (2017). Update: use of the benchmark dose approach in risk assessment.
EFSA Journal, 15(1), e04658.

+ Hurvich, CM, Tsai, CL (1989). Regression and time series model selection in small samples. Biometrika, 76(2), 297-307.

+ Larras F, Billoir E, Baillard V, Siberchicot A, Scholz S, Wubet T, Tarkka M, Schmitt-Jansen M and Delignette-Muller ML (2018). DRomics : a turnkey tool to support the use of the dose-response framework for omics data in ecological risk assessment. Environmental Science & Technology. [https://pubs.acs.org/doi/10.1021/acs.est.8b04752](https://pubs.acs.org/doi/10.1021/acs.est.8b04752).
You can also find this article at : [https://hal.archives-ouvertes.fr/hal-02309919](https://hal.archives-ouvertes.fr/hal-02309919)

+ Larras F, Billoir E, Scholz S, Tarkka M, Wubet T, Delignette-Muller ML, Schmitt-Jansen M (2020). A multi-omics concentration-response framework uncovers novel understanding of triclosan effects in the chlorophyte Scenedesmus vacuolatus. Journal of Hazardous Materials. [https://doi.org/10.1016/j.jhazmat.2020.122727](https://doi.org/10.1016/j.jhazmat.2020.122727).

